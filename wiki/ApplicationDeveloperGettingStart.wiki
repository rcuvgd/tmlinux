= Introduction =

  This page describes how to compile your applications and run them on tmlinux.


= Details =


==Preparation:== 
  === 1. Get and install TCS Linux edition.===

  First of all, you should install TCS Linux edition on your Linux machines. Please goto [http://www.tcshelp.com] to get it. Of course, you should have the license for it. 
  In the following section, let's support the installation directory of your TCS is _*/opt/NXP/TCS510/*_ 

  === 2. Checkout sysroots from this project's svn.===
  Now make your work directory (suppose it is _*/home/guohr/worktest/*_), at this directory, use the following command to get the sysroots:
  {{{
cd /home/guohr/worktest/
svn checkout http://tmlinux.googlecode.com/svn/trunk/sysroots/
  }}}
  === 3. Setup application building environment.===
  Make sure the TCS tools(such as tmcc, tmld) in the PATH environment and the compiler for your application building in the PATH environment.
    {{{
export PATH=$PATH:/opt/NXP/TCS510/bin/
export PATH=$PATH:/home/guohr/worktest/sysroots/pnx1500_ttisim_uclibc/x86-linux2/
  }}}
  
  To validate the environment, at shell, use the following command, the result will like this:
  {{{
guohr@ghr-notebook-02:~/worktest> tmcc -V
tmcc: V7.1.0 of TCS V5.1(0042rc6_Linux)
tmcc warning : no work
  }}}
  {{{
guohr@ghr-notebook-02:~/worktest>trimedia-gss-linux-tcs-pnx1500el_fp64-uclibc-gcc -V
tmcc: V7.1.0 of TCS V5.1(0042rc6_Linux)
tmcc warning : no work
  }}}
  === 4. Create TCS environment for building your applications.===
  To create the whole TCS environment for building tmlinux applications, you need to goto *_sysroots/sysroots/pnx1500_ttisim_uclibc/tcs/5.1.0_* and then use the following command:
  {{{
cd /home/guohr/worktest/sysroots/pnx1500_ttisim_uclibc/tcs/5.1.0
TCS=/opt/NXP/TCS510 ./creat-tcs.sh
  }}}
  Please set TCS with your TCS installation path (In the above example, it is *_/opt/NXP/TCS510_*).

==Build your application:==  
  === 1. Note about tmlinux applications ===
  Now, you can compile your exist application, but before compiling them, please note that:
  * INPUT/OUTPUT FUNCTIONS CANNOT WORK
  Until now, tmlinux can only run on trimedia simulator. In another words, it can not run on any real boards. Because of lacking real output devices, this linux kernel directs stdout/stderr to /dev/null, which means that these output functions (such as `printf()`, `puts()`) will output nothing. Because of lacking real input devices, this linux kernel will wait forever when application calls input functions (such as `gets()`, `getchar()`)

  * WITHOUT `PRINTF()`, HOW CAN I SEE APPLICATION RUNNING
  As I said before, tmlinux's `printf()` just output information to /dev/null. To see application running, I use *TCS*'s `printf()` instead of tmlinux's `printf()`. So, in the following code,
{{{
#include <stdio.h>

int
main(void)
{
   printf("Hello world!\n");
   return 0;
}
}}}
  the *printf()* here is provided by TCS but not tmlinux. So it still can output information when using ttisim. 
  But *PLEASE DO NOTE THAT:* high frequent `printf()` may cause the TCS system suspend, so try to avoid this situation.

  === 2. Build your applications===
  Ok, you can compile your applications. It is as simple as compiling the simplest 'hello world' application, Just replace your compiler with *trimedia-gss-linux-tcs-pnx1500el_fp64-uclibc-gcc*
  {{{
trimedia-gss-linux-tcs-pnx1500el_fp64-uclibc-gcc hello.c -o hello.out
  }}}

  There are some test cases for tmlinux application in svn. Please use the following command to check them out and just type make to compile them.
  {{{
/*suppose you are in /home/guohr/worktest directory*/
svn checkout http://tmlinux.googlecode.com/svn/trunk/app-test/
cd app-test
make
  }}} 

  If successful, you will get some .out binary applications in *_app-test_* directory.

  Please see TmlinuxAppExample for examples.
  
== Run your applications==
  You have got your binary applications and you are eager to run your applications and see their output result. But please wait, you have just got binary applications but not linux kernel. Now, your need to 
 * put your binary applications into the target root file system.
 * convert the target root file system to initramfs cpio file.
 * Build your linux kernel with this initramfs cpio file embedded.

  === 1. Install cil (C intermedia language) ===

  Note that: before continue, you need to make sure you have installed OCaml language compiler. OCaml can be downloaded from http://caml.inria.fr/ocaml/. After downloading and unpacking the source distribution, in the ocaml directory, do:
  {{{
./configure
make world
make opt
make install
  }}}

  Before build linux kernel image, you need to setup and install cil in your linux machine, which is used to process GNU C extenstion options when compiling linux kernel.
  
  Use the following command to check it out and compile, setup it.
  {{{
svn checkout http://tmlinux.googlecode.com/svn/trunk/cil
cd cil/
./configure
make  
export PATH=$PATH:/home/guohr/worktest/cil/obj/x86_LINUX/
  }}}

  To validate the environment, type the following command and you will get the following message:
{{{
guohr@ghr-notebook-01:~/worktest/cil> cilly.asm.exe

Error: No arguments for CIL

Fatal error: exception Errormsg.Error
}}}

  === 2. Arrange target root file system and create initramfs cpio file ===

  To build your linux system(kernel and target root filesystem), you need to download the tmlinux kernel object files from http://tmlinux.googlecode.com/files/tmlinux-kernel-obj-latest.tar.bz2, and then unpack it.

  Now make a directory as the target root filesystem directory (suppose it is *_/home/guohr/worktest/export_*). The kernel of tmlinux will load its first application, which name is *_init_* and located at the target root directory. So you need to copy the application you want to run to the target root directory and rename it to *_init_*.
  E.g:
{{{
mkdir export
cp app-test/hello.out ./export/init -fr
}}}
  Do not forget to assign runnable permission to the binary applications
{{{
chmod a+x ./export/init
}}}

  Because regular users can not make device node files and the basic target root filesystem needs them, I suggest that you write a initramfs list file (in this example, it is named *_initramfs_list_* and located at *_/home/guohr/worktest directory_*) which contains the device node files information:
{{{
# This is a very simple, default initramfs

dir /dev 0755 0 0
nod /dev/console 0600 0 0 c 5 1
nod /dev/zero 0600 0 0 c 1 5
dir /root 0700 0 0
}}}
 
  Now change to *_linux-obj_* directory at the work directory. And use `make menuconfig` to change the *CONFIG_INITRAMFS_SOURCE* option.
{{{
cd linux-obj
make menuconfig
select "General setup -> Initramfs source file(s)"
set "/home/guohr/worktest/initramfs_list /home/guohr/worktest/export"
save and quite
}}}
  while `/home/guohr/worktest/initramfs_list` is the full path of that initramfs list file and `/home/guohr/worktest/export` is the target root directory in which contains your applications.

  Tips: you can edit *.config* file located at linux-obj directly. Just set
{{{
CONFIG_INITRAMFS_SOURCE="/home/guohr/worktest/initramfs_list /home/guohr/worktest/export"
}}}
  and then save and quite.

  === 3. Build linux kernel image ===

  At *_linux-obj_* directory, type `make` and you will get the linux runnable image with target root file system embedded.
{{{
guohr@ghr-notebook-01:~/worktest/linux-obj$ make
  CHK     include/linux/version.h
  GEN     include/asm-trimedia/asm-offsets.h
  CHK     include/linux/compile.h
  CHK     usr/initramfs_list
  GEN     usr/initramfs_data.h
  GEN     usr/initramfs_len.h
  CC      usr/initramfs_data.o
  LD      usr/built-in.o
  GEN     .version
  CHK     include/linux/compile.h
  UPD     include/linux/compile.h
  CC      init/version.o
  LD      init/built-in.o
  LD      vmlinux
  SYSMAP  System.map
}}}

  If success, the linux image is `arch/trimedia/boot/TMLinux-pnx1500-ttisim-fp64-el.out`

  === 4. Run this linux system and see your application running ===